# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' rcpp_centrality_vertex - parallel function
#'
#' sample is used to estimate timing, by calculating centrality from just a few
#' vertices.
#' @noRd
rcpp_centrality <- function(graph, vert_map_in, heap_type, dist_threshold, edge_centrality, sample) {
    .Call(`_exposure_rcpp_centrality`, graph, vert_map_in, heap_type, dist_threshold, edge_centrality, sample)
}

#' rcpp_flows_aggregate_par
#'
#' @param graph The data.frame holding the graph edges
#' @param vert_map_in map from <std::string> vertex ID to (0-indexed) integer
#' index of vertices
#' @param fromi Index into vert_map_in of vertex numbers
#' @param toi Index into vert_map_in of vertex numbers
#' @param tol Relative tolerance in terms of flows below which targets
#' (to-vertices) are not considered.
#'
#' @note The parallelisation is achieved by dumping the results of each thread
#' to a file, with aggregation performed at the end by simply reading back and
#' aggregating all files. There is no way to aggregate into a single vector
#' because threads have to be independent. The only danger with this approach
#' is that multiple threads may generate the same file names, but with names 10
#' characters long, that chance should be 1 / 62 ^ 10.
#'
#' @noRd
rcpp_flows_aggregate_par <- function(graph, vert_map_in, fromi, toi_in, flows, norm_sums, tol, heap_type) {
    .Call(`_exposure_rcpp_flows_aggregate_par`, graph, vert_map_in, fromi, toi_in, flows, norm_sums, tol, heap_type)
}

#' rcpp_flows_disperse_par
#'
#' Modified version of \code{rcpp_flows_aggregate} that aggregates flows to all
#' destinations from given set of origins, with flows attenuated by distance
#' from those origins.
#'
#' @param graph The data.frame holding the graph edges
#' @param vert_map_in map from <std::string> vertex ID to (0-indexed) integer
#' index of vertices
#' @param fromi Index into vert_map_in of vertex numbers
#' @param k Coefficient of (current proof-of-principle-only) exponential
#' distance decay function.  If value of \code{k<0} is given, a standard
#' logistic polynomial will be used.
#'
#' @note The flow data to be used for aggregation is a matrix mapping flows
#' betwen each pair of from and to points.
#'
#' @noRd
rcpp_flows_disperse_par <- function(graph, vert_map_in, fromi, k, dens, tol, heap_type) {
    .Call(`_exposure_rcpp_flows_disperse_par`, graph, vert_map_in, fromi, k, dens, tol, heap_type)
}

#' rcpp_flows_si
#'
#' @param graph The data.frame holding the graph edges
#' @param vert_map_in map from <std::string> vertex ID to (0-indexed) integer
#' index of vertices
#' @param fromi Index into vert_map_in of vertex numbers
#' @param toi Index into vert_map_in of vertex numbers
#' @param kvec Vector of k-values for each fromi
#' @param nvec Vector of density-values for each fromi
#' @param tol Relative tolerance in terms of flows below which targets
#' (to-vertices) are not considered.
#'
#' @noRd
rcpp_flows_si <- function(graph, vert_map_in, fromi, toi_in, kvec, dens_from, dens_to, norm_sums, tol, heap_type) {
    .Call(`_exposure_rcpp_flows_si`, graph, vert_map_in, fromi, toi_in, kvec, dens_from, dens_to, norm_sums, tol, heap_type)
}

#' rcpp_points_index_par
#'
#' Get index of nearest vertices to list of points
#'
#' @param graph Rcpp::DataFrame containing the graph
#' @param pts Rcpp::DataFrame containing the routing points
#'
#' @return 0-indexed Rcpp::NumericVector index into graph of nearest points
#'
#' @noRd
rcpp_points_index_par <- function(xy, pts) {
    .Call(`_exposure_rcpp_points_index_par`, xy, pts)
}

#' rcpp_get_sp_dists_par
#'
#' @noRd
rcpp_get_sp_dists_par <- function(graph, vert_map_in, fromi, toi_in, heap_type, is_spatial) {
    .Call(`_exposure_rcpp_get_sp_dists_par`, graph, vert_map_in, fromi, toi_in, heap_type, is_spatial)
}

#' rcpp_get_iso
#'
#' @noRd
rcpp_get_iso <- function(graph, vert_map_in, fromi, dlim, heap_type) {
    .Call(`_exposure_rcpp_get_iso`, graph, vert_map_in, fromi, dlim, heap_type)
}

#' rcpp_get_sp_dists
#'
#' @noRd
rcpp_get_sp_dists <- function(graph, vert_map_in, fromi, toi_in, heap_type) {
    .Call(`_exposure_rcpp_get_sp_dists`, graph, vert_map_in, fromi, toi_in, heap_type)
}

#' rcpp_get_paths
#'
#' @param graph The data.frame holding the graph edges
#' @param vert_map_in map from <std::string> vertex ID to (0-indexed) integer
#' index of vertices
#' @param fromi Index into vert_map_in of vertex numbers
#' @param toi Index into vert_map_in of vertex numbers
#'
#' @note The graph is constructed with 0-indexed vertex numbers contained in
#' code{vert_map_in}. Both \code{fromi} and \code{toi} already map directly
#' onto these. The graph has to be constructed by first constructing a
#' \code{std::map} object (\code{vertmap}) for \code{vert_map_in}, then
#' translating all \code{graph["from"/"to"]} values into these indices. This
#' construction is done in \code{inst_graph}.
#'
#' @note Returns 1-indexed values indexing directly into the R input
#'
#' @noRd
rcpp_get_paths <- function(graph, vert_map_in, fromi, toi_in, heap_type) {
    .Call(`_exposure_rcpp_get_paths`, graph, vert_map_in, fromi, toi_in, heap_type)
}

